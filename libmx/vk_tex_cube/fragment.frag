#version 450
layout(location = 0) in vec2 fragTexCoord;
layout(location = 0) out vec4 outColor;

layout(binding = 0) uniform sampler2D texSampler;
layout(binding = 1) uniform UniformBufferObject {
    vec2 iResolution;
    float time_f;
    float _pad0;
    vec4 iMouse;
} ubo;

const float PI = 3.1415926535897932384626433832795;

float pingPong(float x, float length){
    float m = mod(x, length*2.0);
    return m <= length ? m : length*2.0 - m;
}

vec3 hsv2rgb(vec3 c){
    vec4 K=vec4(1.0,2.0/3.0,1.0/3.0,3.0);
    vec3 p=abs(fract(c.xxx+K.xyz)*6.0-K.www);
    return c.z*mix(K.xxx,clamp(p-K.xxx,0.0,1.0),c.y);
}

vec2 rotateUV(vec2 uv, float angle, vec2 c, float aspect){
    float s = sin(angle), cc = cos(angle);
    vec2 p = uv - c;
    p.x *= aspect;
    p = mat2(cc, -s, s, cc) * p;
    p.x /= aspect;
    return p + c;
}

vec2 reflectUV(vec2 uv, float segments, vec2 c, float aspect){
    vec2 p = uv - c;
    p.x *= aspect;
    float ang = atan(p.y, p.x);
    float rad = length(p);
    float stepA = 6.28318530718 / segments;
    ang = mod(ang, stepA);
    ang = abs(ang - stepA * 0.5);
    vec2 r = vec2(cos(ang), sin(ang)) * rad;
    r.x /= aspect;
    return r + c;
}

vec2 fractalFold(vec2 uv, float zoom, float t, vec2 c, float aspect){
    vec2 p = uv;
    for(int i=0;i<3;i++){
        p = abs((p - c) * (zoom + 0.15*sin(t*0.35+float(i)))) - 0.5 + c;
        p = rotateUV(p, t*0.12 + float(i)*0.07, c, aspect);
    }
    return p;
}

vec3 neonPalette(float t){
    vec3 pink  = vec3(1.0, 0.15, 0.75);
    vec3 blue  = vec3(0.10, 0.55, 1.0);
    vec3 green = vec3(0.10, 1.00, 0.45);
    float ph = fract(t*0.08);
    vec3 k1 = mix(pink,  blue,  smoothstep(0.00, 0.33, ph));
    vec3 k2 = mix(blue,  green, smoothstep(0.33, 0.66, ph));
    vec3 k3 = mix(green, pink,  smoothstep(0.66, 1.00, ph));
    float a = step(ph, 0.33);
    float b = step(0.33, ph) * step(ph, 0.66);
    float c = step(0.66, ph);
    return normalize(a*k1 + b*k2 + c*k3) * 1.05;
}

vec3 softTone(vec3 c){
    c = pow(max(c, 0.0), vec3(0.95));
    float l = dot(c, vec3(0.299,0.587,0.114));
    c = mix(vec3(l), c, 0.9);
    return clamp(c, 0.0, 1.0);
}

vec3 tentBlur3(vec2 uv, vec2 res){
    vec2 ts = 1.0 / res;
    vec3 s00 = textureGrad(texSampler, uv + ts*vec2(-1.0,-1.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s10 = textureGrad(texSampler, uv + ts*vec2( 0.0,-1.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s20 = textureGrad(texSampler, uv + ts*vec2( 1.0,-1.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s01 = textureGrad(texSampler, uv + ts*vec2(-1.0, 0.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s11 = textureGrad(texSampler, uv, dFdx(uv), dFdy(uv)).rgb;
    vec3 s21 = textureGrad(texSampler, uv + ts*vec2( 1.0, 0.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s02 = textureGrad(texSampler, uv + ts*vec2(-1.0, 1.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s12 = textureGrad(texSampler, uv + ts*vec2( 0.0, 1.0), dFdx(uv), dFdy(uv)).rgb;
    vec3 s22 = textureGrad(texSampler, uv + ts*vec2( 1.0, 1.0), dFdx(uv), dFdy(uv)).rgb;
    return (s00 + 2.0*s10 + s20 + 2.0*s01 + 4.0*s11 + 2.0*s21 + s02 + 2.0*s12 + s22) / 16.0;
}

vec3 preBlendColor(vec2 uv){
    vec3 tex = tentBlur3(uv, ubo.iResolution);
    vec2 gdir = normalize(vec2(cos(ubo.time_f*0.27), sin(ubo.time_f*0.31)));
    float s = dot((uv-0.5)*vec2(ubo.iResolution.x/ubo.iResolution.y,1.0), gdir);
    float w = max(fwidth(s)*4.0, 0.002);
    float band = smoothstep(-0.5-w, -0.5+w, sin(s*2.2 + ubo.time_f*0.9));
    vec3 neon = neonPalette(ubo.time_f);
    vec3 grad = mix(tex, mix(tex, neon, 0.6), 0.35 + 0.25*band);
    grad = mix(grad, tex, 0.10);
    grad = softTone(grad);
    return grad;
}

float diamondRadius(vec2 p){
    p = abs(p);
    return max(p.x, p.y);
}

vec2 diamondFold(vec2 uv, vec2 c, float aspect){
    vec2 p = (uv - c) * vec2(aspect, 1.0);
    p = abs(p);
    if(p.y > p.x) p = p.yx;
    p.x /= aspect;
    return p + c;
}

void main(void){
    vec4 baseTex = texture(texSampler, fragTexCoord);

    vec2 uv = fragTexCoord * 2.0 - 1.0;
    uv.x *= ubo.iResolution.x / ubo.iResolution.y;
    float radius = mix(0.8, 1.2, 0.5 + 0.5 * sin(ubo.time_f * 1.3));
    radius *= 2.0;
    float r = length(uv);
    float glow = smoothstep(radius, radius - 0.25, r);

    float aspect = ubo.iResolution.x / ubo.iResolution.y;
    vec2 m = (ubo.iMouse.z > 0.5) ? (ubo.iMouse.xy / ubo.iResolution) : vec2(0.5);
    vec2 ar = vec2(aspect, 1.0);

    vec3 baseCol = preBlendColor(fragTexCoord);

    float seg = 4.0 + 2.0*sin(ubo.time_f*0.33);
    vec2 kUV = reflectUV(fragTexCoord, seg, m, aspect);
    kUV = diamondFold(kUV, m, aspect);
    float foldZoom = 1.45 + 0.55 * sin(ubo.time_f * 0.42);
    kUV = fractalFold(kUV, foldZoom, ubo.time_f, m, aspect);
    kUV = rotateUV(kUV, ubo.time_f * 0.23, m, aspect);
    kUV = diamondFold(kUV, m, aspect);

    vec2 p = (kUV - m) * ar;
    vec2 q = abs(p); if(q.y > q.x) q = q.yx;

    float base = 1.82 + 0.18*sin(ubo.time_f*0.2);
    float period = log(base);
    float tz = ubo.time_f * 0.65;
    float rD = max(diamondRadius(p), 0.15) + 1e-6;
    float ang = atan(q.y, q.x) + tz * 0.35 + 0.35*sin(rD*18.0 + ubo.time_f*0.6);
    float k = fract((log(rD) - tz) / period);
    float rw = exp(k * period);
    vec2 pwrap = vec2(cos(ang), sin(ang)) * rw;

    vec2 u0 = fract(pwrap / ar + m);
    vec2 u1 = fract((pwrap*1.045) / ar + m);
    vec2 u2 = fract((pwrap*0.955) / ar + m);

    vec2 dir = normalize(pwrap + 1e-6);
    vec2 off = dir * (0.0015 + 0.001 * sin(ubo.time_f*1.3)) * vec2(1.0, 1.0/aspect);

    float vign = 1.0 - smoothstep(0.75, 1.2, length((fragTexCoord - m)*ar));
    vign = mix(0.9, 1.15, vign);

    vec3 rC = preBlendColor(u0 + off);
    vec3 gC = preBlendColor(u1);
    vec3 bC = preBlendColor(u2 - off);
    vec3 kaleidoRGB = vec3(rC.r, gC.g, bC.b);

    float ring = smoothstep(0.0, 0.7, sin(log(rD+1e-3)*9.5 + ubo.time_f*1.2));
    float pulse = 0.5 + 0.5*sin(ubo.time_f*2.0 + rD*28.0 + k*12.0);

    vec3 finalCol = kaleidoRGB;
    finalCol *= (0.75 + 0.25*ring) * (0.85 + 0.15*pulse) * vign;
    vec3 bloom = finalCol*finalCol*0.18 + pow(max(finalCol-0.6,0.0), vec3(2.0))*0.12;
    finalCol += bloom;
    finalCol = mix(finalCol, baseCol, 0.18);
    finalCol = clamp(finalCol, vec3(0.05), vec3(0.97));

    vec3 finalRGB = mix(baseTex.rgb, finalCol, pingPong(glow * PI, 5.0) * 0.8);
    outColor = vec4(finalRGB, baseTex.a);
    outColor.a = 0.5;
}
