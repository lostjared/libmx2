#!/usr/bin/env python3
import math
import argparse

def torus_vertex(u, v, R, r):
    """
    Compute the vertex position of a torus for given parameters.
    u, v: angles in radians.
    R: major radius (distance from center of tube to center of torus)
    r: minor radius (radius of the tube)
    """
    x = (R + r * math.cos(v)) * math.cos(u)
    y = (R + r * math.cos(v)) * math.sin(u)
    z = r * math.sin(v)
    return (x, y, z)

def compute_normal(u, v, R, r):
    """
    Compute the normal at a point on the torus.
    The normal is the vector from the center of the torus tube circle to the surface point.
    """
    # Compute the vertex position
    x, y, z = torus_vertex(u, v, R, r)
    # Center of the tube circle (lying in the XY-plane)
    cx = R * math.cos(u)
    cy = R * math.sin(u)
    cz = 0.0
    # Normal is the difference, normalized
    nx = x - cx
    ny = y - cy
    nz = z - cz
    length = math.sqrt(nx*nx + ny*ny + nz*nz)
    if length == 0:
        return (0.0, 0.0, 0.0)
    return (nx / length, ny / length, nz / length)

def generate_torus(R, r, segments_N, segments_M):
    """
    Generate vertices, texture coordinates, and normals for a torus.
    The torus is generated by sampling angles u and v.
    Each quad cell is split into two triangles.
    """
    vertices = []
    textures = []
    normals = []
    
    for i in range(segments_N):
        # u: angle around the torus' main circle
        u = 2 * math.pi * i / segments_N
        u_next = 2 * math.pi * ((i+1) % segments_N) / segments_N
        
        for j in range(segments_M):
            # v: angle around the tube circle
            v = 2 * math.pi * j / segments_M
            v_next = 2 * math.pi * ((j+1) % segments_M) / segments_M
            
            # Compute vertices for the four corners of the current quad
            v0 = torus_vertex(u,      v,      R, r)
            v1 = torus_vertex(u_next, v,      R, r)
            v2 = torus_vertex(u_next, v_next, R, r)
            v3 = torus_vertex(u,      v_next, R, r)
            
            # Texture coordinates (normalized between 0 and 1)
            t0 = (i / segments_N,      j / segments_M)
            t1 = ((i+1) / segments_N,  j / segments_M)
            t2 = ((i+1) / segments_N, (j+1) / segments_M)
            t3 = (i / segments_N,     (j+1) / segments_M)
            
            # Normals at each vertex
            n0 = compute_normal(u,      v,      R, r)
            n1 = compute_normal(u_next, v,      R, r)
            n2 = compute_normal(u_next, v_next, R, r)
            n3 = compute_normal(u,      v_next, R, r)
            
            # Split the quad into two triangles:
            # Triangle 1: vertices v0, v1, v2
            vertices.extend([v0, v1, v2])
            textures.extend([t0, t1, t2])
            normals.extend([n0, n1, n2])
            
            # Triangle 2: vertices v0, v2, v3
            vertices.extend([v0, v2, v3])
            textures.extend([t0, t2, t3])
            normals.extend([n0, n2, n3])
    
    return vertices, textures, normals

def write_mxmod_file(filename, vertices, textures, normals):
    """
    Write out the MXMOD file.
    The file format is:
      tri <shape_type> <texture_index>
      vert <number_of_vertices>
      [vertex coordinates: x y z per line]
      tex <number_of_texture_coords>
      [texture coordinates: u v per line]
      norm <number_of_normals>
      [normal coordinates: nx ny nz per line]
    """
    num_vertices = len(vertices)
    with open(filename, 'w') as f:
        f.write("tri 0 0\n")
        f.write("vert {}\n".format(num_vertices))
        for v in vertices:
            f.write("{:.6f} {:.6f} {:.6f}\n".format(*v))
        f.write("tex {}\n".format(num_vertices))
        for t in textures:
            f.write("{:.6f} {:.6f}\n".format(*t))
        f.write("norm {}\n".format(num_vertices))
        for n in normals:
            f.write("{:.6f} {:.6f} {:.6f}\n".format(*n))
            
def main():
    parser = argparse.ArgumentParser(description="Generate a MXMOD file for a torus.")
    parser.add_argument("--output", type=str, default="torus.mxmod", help="Output MXMOD file name")
    parser.add_argument("--R", type=float, default=2.0, help="Major radius of the torus")
    parser.add_argument("--r", type=float, default=0.5, help="Minor radius of the torus")
    parser.add_argument("--segments_N", type=int, default=32, help="Number of segments around the torus (major circle)")
    parser.add_argument("--segments_M", type=int, default=16, help="Number of segments for the tube (minor circle)")
    args = parser.parse_args()
    
    vertices, textures, normals = generate_torus(args.R, args.r, args.segments_N, args.segments_M)
    write_mxmod_file(args.output, vertices, textures, normals)
    print("MXMOD file '{}' generated with {} triangles.".format(args.output, len(vertices) // 3))

if __name__ == '__main__':
    main()
